# 学习《javascript设计模式与开发设计》艺术的笔记

#### 设计模式的定义：在面向对象软件设计过程中，针对特定问题的简洁而优雅的解决方案

## 第一章：面向对象的javascript{#index}
> javascript没有提供传统面向对象语言中的
__类式继承__,而是通过 __原型委托__ 的方式来实现对象与对象之间的继承。
>

## 1.1 动态类语言和鸭子类型

>__静态类型语言__:在编译时已确定变量的类型
>
>__动态类型语言__:运行时变量被赋予某个值后，才会具有某种类型

* javascript中，当我们对一个变量赋值时，无需考虑类型，故是典型的动态类型语言。这一切都建立在鸭子类型 __duck typing__ 概念上，这个概念指导我们，关注对象行为，而非对象本身。就是说 __Has-A 。利用鸭子类型的思想，我们不必借助超类型的帮助，就能轻松在动态类型语言中实现一个原则：面向接口编程，而不是面向实现编程。

## 1.2 多态
> 含义：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。多态的思想是： __做什么__ 和 __谁做和怎么做__ 分开。多态性的表现是实现众多设计模式的目标。 
>
>使用 __继承__ 来得到多态效果，是让对象表现出多态性的最常用手段。继承通常包括 __实现继承__ 和 __接口继承__ 。

* 要实现多态的分离思想，归根结底要先消除类型之间的耦合关系。如果类型之间的耦合关系没有被消除，那么指定操作的对象类型是不可变的，就不可能再被替换成另外一个类型。在JAVA中，可以通过向上转型来实现多态。而在javascript中，一个object，可以表示多个类型，所以javascript的多态性是与生俱来的。因为它作为一门动态语言，在编译时没有类型检查的过程，既没有检查创建的对象类型，又没有检查传递的参数类型。

>多态在面向对象程序设计中的作用
* 多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。
* 将行为分布在各个对象中，并让这些对象各自负责自己的行为，正式面向对象设计的优点。


## 1.3 封装
>封装的目的是将信息隐藏。一般而言，我们讨论的封装是封装数据和封装实现，在此，还要讨论 __封装类型__ 和 __封装变化__;

* 封装数据：许多语言中，封装数据有语法解析来实现，例如提供private、 public、protected等关键字来提供不同的访问权限。但是javascript并没有提供对这些关键字的支持，只能依赖 __变量的作用域__ 来实现封装特性。而且只能模拟出public和private两种封装性。

        var myObject =(
            function(){
               var __name = 'cyh', //私有变量
               return{
                   getName:()=>{ //公开方法
                       console.log(__name)
                   }
               }
            }
        )()

* 封装实现： 封装的目的是将信息隐藏，从封装实现细节来讲，封装是的对象内部的变化对于其他对象是不可见的。封装是的对象的耦合变松散，对象之间只要通过暴露的API接口来通信。

* 封装类型：封装类型是静态语言中的重要封装方式，在一些模式中，要尽量去隐藏对象的类型。但对于javascript,并没有对抽象类和接口的支持。

* 封装变化：我们知道，设计模式分别被划分为 __创建型模式__ , __结构性模式__ ,和 __行为型模式__ ; 拿创建者模式来说,要创建一个对象，是一种抽象行为，而具体创建什么对象则是可变化的。创建型模式的目的就是封装创建对象的变化。而结构型模式封装的是对象之间的组合关系，行为型模式封装的是对象的行为变化。  
通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分分割开来，在系统的演变过程中，只需替换容易变化的部分。这样替换起来容易，可以最大程度保证程序的稳定性和可拓展性。


## 1.4 原型模式和基于原型继承的javascript对象系统
>JavaScript没有 __类__ 的概念;
*  在以类为中心的面向对象编程语言中，类和对象的关系可以是铸模和铸件的关系，对象总是从类中创建而来。在原型编程的思想中，类并不是必须的，独享未必需要从类中创建而来。一个对象是通过克隆另外一个对象所得到的。  
原型模式不单是一种设计模式，也被称为一种 __编程泛型__

> 使用克隆的原型模式
* 要创建对象，一般是先指定它的类型，然后通过类来创建对象; __原型模式__ 选择另一种方式： 不在关心对象的具体类型，而是找到一个对象，通过克隆来创建一个一模一样的对象 。
* 原型模式是实现关键，是语言是否提供 __clone__ 方法。ES5提供了Object.create方法，用来克隆对象

        var Plane = function(){
            this.blood = 100;
        }
        var plane = new Plane();
        plane.blood = 500;

        var clonePlane = Object.create( plane );
        console.log( clonePlane )

* 克隆是创建对象的手段，而非目的。目的是提供一种便捷的方法去创建某个类型的对象。通过克隆对象，不用再关心对象的具体类型名字。在JS中，创建对象非常容易，也不存在类型耦合的问题。原型模式的意义不大，所以成职位原型编程泛型更为合适。

> 原型编程范型的基本规则
* 所有的数据都是对象
* 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它
* 对象会记住它的原型
* 如果对象无法响应某个请求，会把该请求委托给自己的原型

> javascript的原型继承
* 所有数据都是对象; javascript在设计的时候，模仿Java引入两套类型机制：基本类型和对象类型。  
javascript的根对象是Object.prototype对象，此对象是一个空对象。我们在JS遇到的每个对象，实际都是从Object.prototype对象克隆而来的。

>javascript中没有类，为何有new 

        function Person(name){
            this.name = name;
        }

* 这里的Person并不是类，而是函数构造器，javascript的函数既可以作为普通函数被调用，也可以作为构造器来被调用。当使用new 运算符来调用函数时，此时的函数就是一个 __构造器__。用new 实际上也是克隆 Object.prototype对象，再进行一些额外操作的过程。

* 我们一直说 __对象的原型__ ,其实就JS的真正实现来说，并不能说对象有原型，只能说对象的构造器有原型。因此对象的请求委托，切确地说是委托给构造器的原型。
* 实际上，虽然JS的对象最初都是由Object.prototype对象克隆出来的，但对象构造器的原型并不仅限于Object.prototype上，而是可以动态指向其他对象。

> 如何实现“类”的“继承”

         var A = function(){}
         A.prototype ={ name :'cyh'};

         var B = function(){};
         B.prototype = new A();

* 可以发现,通过new A() 的方式，比把B.prototype直接指向一个字面量对象相比，形成的原型链会多一层。但是二者本质没有区别。都是讲构造器的原型指向另外一个对象。 __继承总是发生在对象和对象之间__。
* 原型链并不是无限长的，因为根对象Object.prototype的原型是null, 请求就此停止，返回undefined;
* Object.create()是原型模式的天然实现。但是用该方法创建对象的效率并不高，比构造函数创建对象要慢。 此外要注意，通过构造函数创建的对象，都会有原型。但是通过Object.create(null),可以创建出没有原型的对象。

## 第二章：this, call, apply

> this
* javascript总是指向一个 __对象__，而具体指向那个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境.
* 除去不常用的with 和 eval 的情况，实际this指向大致可以分为  
1、作为对象的方法调用,当函数作为对象的方法被调用时，this指向该对象  
2、作为普通函数调用，this指向global对象

      var a = 'global"
      var obj ={
        a:'limit',
        getA:function(){
            this.a
        }
      }

      obj.getA()  // limit
      var func = obj.getA;
      func() // global

3、构造器调用  
* 除了宿主提供的一些内置函数，大部分Javascript函数都可以当做构造器使用。当用 __new__ 运算符调用函数时，该函数总会返回一个对象。通常构造器里的this就会指向返回的这个对象。

        var MyClass = function(){
            this.name = 'seve'
        }
        var obj = new MyClass();
        console.log( obj.name) // seve

用new 调用构造函数时，应注意：如果构造器 __显式__ 地返回一个object类型对象，那么此次运算结果最终会返回这个对象，而不是this;

        var MyClass = function(){
            this.name = 'seve';
            return{
                name:'anne'
            }
        }
        var obj = new MyClass();
        console.log( obj.name) // anne

4、Function.prototype.call 或 Function.prototype.apply 调用
* 跟普通函数相比,上面的方法可以动态地改变传入函数的this。几乎每一次编写函数式语言风格的代码，都离不开call 和 apply 。

> call 和 apply 的区别
* 两者作用一模一样，区别仅在于传入参数形式的不同。apply的参数，第一个为函数体内this对象的指向，第二个参数为一个带下表的集合，可以为数组或类数组。
* call其实是包装了apply的语法糖，如果明确知道函数接受了多少个参数，可以用call传参。
* 当传入的第一个参数为 null ,函数体内的this会指向默认的宿主对象。
* 有时候使用call 或 apply,目的不是指定this指向，而是借用其他对象的方法。
 
        Math.max.apply( null, [1,2,3,4,5])

> call 和 apply的用途
* 1、改变this指向
* 2、Function.prototype.bind 一般浏览器会内置，但是即使没有，也可以模拟

        Function.prototype.bind = function( context ){
            var self = this ;
            return function(){
                console.log( this ) // window or undifined
                return self.apply( context , arguments )
            }
        }

        var obj = {
            name:'cyh'
        }

        var func = function(){
            alert( this.name)
        }.bind( obj );

        func(); // cyh


## 第三章：闭包和高阶函数

#### 虽然js是一门完整的OO语言，但是这门语言也有许多函数式语言的特性。

### 闭包
* 闭包的形成与变量的 __作用域_ _以及变量的 __生存周期__ 密切相关

>作用域 : 变量的有效范围，最常指函数中声明的变量作用域，即局部变量

* 在JS中，函数可以用来创造函数的作用域。函数内单向可见函数外的变量。当函数内没有声明某个变量，那搜索过程会随着代码执行环境创建的 __作用域链__ 往外逐层搜索，一直到搜索到全局对象为止。

> 生存周期
* 对于全局变量来说，全局变量的生存周期当然是永久的，除非手动销毁。对于函数内的局部变量来说，退出函数时，这些局部变量边是去价值，随着调用结束而被销毁。

        var func = function(){
            var a = 1;
            return function(){
                a++;
                console.log(a)
            }
        }

        var f = func();
        f();//2
        f();//3
        
* 上面的例子，当退出函数时，局部变量a并没有消失。因为 var f = fun()的时候，f返回一个匿名函数的引用，它可以访问到func()被调用时产生的环境。而局部变量一直处在该环境中，边没有被销毁的理由。这就产生了一个闭包结构。

> 闭包的作用
* __变量封装__ : 可以把不需要暴露在全局的变量封装成私有变量

> 闭包和面向对象设计
* 过程与数据的结合常形容面向对象中的“对象”。对象以方法的形式，包含了过程，而闭包则是在过程中，以环境的形式包含了数据。
* 可以用闭包编写命令模式的代码。  

> 闭包与内存管理

* 闭包是很强大的特性，有一种说法：闭包会造成内存泄露，要减少闭包的使用。 局部变量本来应该在函数调用结束后被解除引用，但如果局部变量被封闭在闭包形成的环境中，那此局部变量就能一直生存下去。从这个意义看，闭包的确会使一些数据无法被及时销毁。使用闭包的一部分原因是我们主动把一些变量封闭在比伯阿忠，因为以后还有可能需要用到这些变量，这种情况下，把变量放在闭包中和放在全局作用域中，对内存方面的影响是一致的，此时便不能说是内存泄露。如果将来需要回收这些变量，可以手动把这些变量设为null ;

*闭包与内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用。 如果闭包的作用域链中保存着一些DOM节点，这时候就可能造成内存泄露。

> 高阶函数：  
> * 函数可以作为参数被传递
> * 函数可以作为返回值输出

> 高阶函数实现AOP(面向切面编程)
* 把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能一般包括日志统计，安全控制，异常处理等。把这些功能抽离出来以后，再"动态织入"的方式掺入业务逻辑模块中。好处是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等模块功能。

>高阶函数的其他应用 (待学习)
> * 柯里化(currying)
> * 反柯里化( uncurrying)
> * 函数节流
  >> 少数情况下，函数的触发不是由用户直接控制的，在这些场景下，函数可能非常频繁地被调用，造成大的性能问题。
  >> * window.onresize
  >> * mousemove
  >> * 文件上传进度  
  >> 以上三个场景，面临的共同问题是函数被触发的频率太高。我们需要按时间段来忽略掉一些事件请求。

        //实现函数节流的代码之一
        var throttle  = function( fn ,interval){
            var __self = fn,
                timer,
                firstTime = true;
            
            return function(){
                var args = arguments,
                    _me = this;
                
                if( firstTime ){ //首次不需延迟
                     __self.apply(__me,args);
                     return firstTime = false l
                }

                if( timer ) { //定时器还在，说明前一次延迟执行还未完成
                     return false;
                }

                timer = setTimeout( function(){
                    clearTimeout( timer );
                    timer = null;
                    __self.apply(__me,args)
                }, interval || 500)
            }
        }

>> 或者也可以采用分时函数：例如分段渲染

>> 惰性加载函数

    //该方法可以在第二次调用时，消除if分支,因为在函数内部，重写了addEvent 方法
    var addEvent = function( elem, type,handler){
        console.log(1)
        if( window.addEventListener ){
            addEvent = function( elem,type,handler){
                elem.addEventListener( type,handler,false)
            }
        }
        if( window.attachEvent ){
            addEvent = function( elem,type,handler){
                elem.attachEvent('on'+ type, handler )
            }
        }
        addEvent(elem,type,handler)
    }
